# LR-Check(左右一致性检查)

## 1、原理

参考文章：【编码实战】经典SGM：（5）视差优化(李迎松) https://zhuanlan.zhihu.com/p/222847345

**错误匹配**直观的反应是聚合后某些像素在真实视差位置的代价值并非最小值，有很多因素能够造成这一现象的产生，如影像噪声、遮挡、弱纹理或重复纹理，以及算法的局限性。实际上目前还没有哪个算法能够完美的处理以上所有问题，所以错误匹配的剔除对所有算法都是有必要的。目前最常用的错误匹配剔除方法是**左右一致性法（L-R Check）**，它基于视差的唯一性约束，即每个像素最多只存在一个正确视差。具体步骤是将左右影像互换位置，即左影像成为右影像，右影像成为左影像，再做一次立体匹配，得到另一张视差图，因为视差图中每个值所反映的是两个像素之间的对应关系，所以依据视差的唯一性约束，通过左影像的视差图，找到每个像素在右影像的同名点像素及该像素对应的视差值，这两个视差值之间的差值若小于一定阈值（一般为1个像素），则满足唯一性约束被保留，反之则不满足唯一性约束而被剔除。一致性检查的公式如式1所示：
$$
D_p=
\left\{
\begin{align*}
D_{bp}\ \ if|D_{bp} - D_{mq}|\leq1\\
D_{invalid}\ \ \ \ \ \ \ otherwisse
\end{align*}
\right.
$$


**一致性检查有两种策略**，一种是内部型，一种是外部型。

- **1. 内部型检查**
- **2. 外部型检查**

我会实现内部型（比较有意思），描述外部型（没技术含量）。内部型就是直接通过左影像的代价数组，来推算右影像的代价数组，从而计算右影像的视差图。所以你只用代价聚合一次就可以做一致性检查。听起来很爽，怎么办到的？秘诀就是：**右影像(i,j)视差为d的代价 = 左影像(i,j+d)视差为d的代价**。根据此秘诀，我们可以将右影像每个像素的所有候选视差的代价值都得到，进而寻找最小代价值对应的视差，并做子像素优化，得到右影像视差图。

## 2、代码实现

## 3、结果实现

## 4、总结